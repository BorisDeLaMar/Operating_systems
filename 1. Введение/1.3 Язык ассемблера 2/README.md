# Язык ассемблера 2  
## Метки и переменные  
**Метка** - просто имя для некоторого адреса.  
Ссылаемся на какое-то место в памяти, хранящее 8-байтное (quad) число 42:
```Assembler
value:
        .quad 42
```
Можем ссылаться на адреса кода. Метка `add42` указывает на начало кода.
```Assembler
add42:
        movq %RDI, %RAX
        addq value, %RAX
        retq
```
## Инструкции безусловного перехода  
Изменяют значение регистра RIP
+ `jmp <label>`: аргумент - метка (ссылка на адрес, по которому надо передать управление)
+ `call <label` - инструкция вызова функции (кроме передачи управления, проделывает дополнительные манипуляции, необходимые для вызова функции)
+ `retq` - инструкция возврата из функции
## Функции  
Необходимые условия для функции:
+ Можно вызвать
+ Возвращает управление *вызывавшему* коду (для этого надо сохранить информацию о том, откуда ее вызвали)
Есть функция main:
```Assembler
main:
	movq $42, %rsi
        call add42
        retq
```
***Что происходит, когда вызывается функция (add42)?***  
1) Процессор запоминает адрес возврата (адрес следующей после `call` инструкции), то есть он сохраняется на стек.
2) Управление передается `add42`, исполняется код функции
3) В конце функции будет инструкция `retq`, которая посмотрит на стеке адрес возврата, удалит его со стека и передаст по нему управление
При этом, если в `add42` сохраняли что-то на стек, перед `retq` нужно все удалить со стека, чтобы на его вершине был адрес возврата
## Флаговый регистр RFLAGS  
Флаги:
* ZF - результат операции 0
* CF - произошло беззнаковое переполнение. Если сложили два больших числа, старшие биты будут отброшены, флаг будет установлен
* OF - произошло знаковое переполнение
*NB Арифметические инструкции изменяют RFLAGS и изменяют свои аргументы*
## Инструкции условного перехода  
* `jcc <label>` - выполняет переход, если условие `cc` истинно
  + `jz`, `je` - проверяет, что ZF = 1
  + `jne`, `jnz` - ZF = 0
  + `jg` - "больше" (знаковое)
  + `jge` - "больше или равно" (знаковое)
  + `ja` - "больше" (беззнаковое)
  + `jae` - "больше или равно" (беззнаковое)
## Инструкции сравнения  
Выставляют флаги, но не меняют аргументы.  
* `cmpq <src>, <dst>` - делает <dst> - <src>, в зависимости от результата выставляет флаги и все. Результат нигде не сохраняет, в отличие от `subq`
## Реализация циклов  
Пример программы: на вход дают два беззнаковых числа x и p (в регистрах RDI и RSI соответственно), программа должна возвращает значение в регистре RAX.  
```Assembler
pow:
	movq $1, %RAX
	cmpq $0, %RSI
	jz ret_t
cycle:
	mulq %RDI
	decq %RSI
	cmpq $0, %RSI
	jz ret_t
	jmp cycle
ret_t:
	retq
```
## Соглагшения  
**ABI** (Application Binary Interface) - набор следующих соглашений:
* Как в функцию передаются параметры
* Как в нее возвращаются значения
* Какие регистры она может использовать, а какие должна сохранить
* и т.п  
В курсе будет использоваться System V ABI (разные компиляторв используют разные ABI).
