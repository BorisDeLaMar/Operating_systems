# Язык ассемблера 1  
Особенности:  
+ Минимум синтаксических правил
+ Много различных инструкций, набор которых зависит от архитектуры

В связи с этим у языка множество диалектов. Будет использоваться **GNU ассемблер** (a.k.a. AT&T).  

## Классы инструкций  
+ Инструкции копирования
  * из памяти в регистр и наоборот
  * из регистра в регистр
  * из памяти в память (реже)
+ Арифметические инструкции ( в т.ч. побитовые операции)
+ Иструкции перехода (обычно процессор выполняет их по порядку, поэтому нужны специальные инструкции, передающие управление в другой участок кода)
  * условного перехода
  * безусловного перехода
+ Прочие инструкции
## Регистр
**Регистры** - быстрые именованные ячейки пвмяти. То есть, у каждого регистра свое имя, а доступ к ним для процессора достаточно быстрый.  
Классы регистров:  
+ Регистры специального назначения - указатель команд (содержит адрес следующей или последней исполненной инструкции), флаговый (хранит состояние процессора)
и много других. Предназначены для решения строго определенных задач.
+ Регистры общего назначения (используем, например, в обычных арифметических операциях: два регистра под слагаемые, один под сумму, а сама операция - инструкция)
Регистры архитектуры x64:
+ Указатель команд - RIP (instruction pointer register)
+ Флаговый - RFLAGS
+ Общего назначения, хотя часть из них определенного назначения:
  * указатель стека - RSP
  * указатель "базы" - RBP
  * RAX, RBX, RCX, RDX, RSI, PDI, R8-R15
## Инструкции
+ `movq <src>, <dst>` - суффикс q означает копирование 64-битные значения
  * `movq %RAX, %RBX` - копирование значения из одного регистра в другой
  * `movq (%RAX), %RAX` - берем значение из RAX, интерпретируем его как адрес, обращаемся по этому адресу в память и достаем 64-битное значение, записываем его в RAX
 (то есть скобки - операция **разименования**)
  * `movq $42, %RAX` - запись конкретного значения в регистр (42)
  * `movq 42, %RAX` - в данном случае 42 интерпретируется как адрес, т.е.  movq обратится по адресу 42 и запишет его знач в RAX
  * `movq $value, %RAX` - для адресов можем заводить имена. Пусть есть имя value, соответствующее какому-то адресу. Знак $ означает, что в качестве
копируемого значения используем сам адрес
  * `movq value, %RAX` - пытаемся разименовать адрес (обратиться по нему и достать значение) и записать уже его
+ `addq <src>, <dist>` - инструкция сложения, сумма сохраняется во второй аргумент
  * `addq %RAX, %RBX`
  * `addq %RAX, value` - берем значение в регистре RAX, добавляем его к значению, которое лежит по адресу value
  * `addq $42, %RAX` - просто прибавляем 42
+ `sub <src>, <dst>` - вычитание первого из второго, не забудь про суффикс размера операндов
+ `incq <op>` - инкремент
  * `incq %RAX`
+ `decq <op>` - декремент
+ `mulq <op>` - беззнаковое умножение. В качетсве второго регистра всегда использует RAX.
  * %RAX = (<op>*%RAX) mod 2^64 - оставляем в RAX младшие 64 бита
  * %RDX = (<op>*%RAX)/2^64 - в RDX кладем старшие 64 бита
+ `divq <op>` - беззнаковое деление. Вычисляет и остаток сразу. Работает со 128-битным значением (RAX и RDX выступают в качестве 1 операнда, который делим на переданный аргумент)
  * %RAX = (%RDX*2^64 + %RAX)/<op> - оставляем в RAX младшие 64 бита
  * %RDX = (%RDX*2^64 + %RAX) mod <op> - в RDX кладем старшие 64 бита
## Стек  
- область памяти, на которую указывает регистр RSP. Этот стек растет вниз, то есть более новые значения на стеке хранятся по меньшим адресам
+ `pushq <src>, <dst>` - уменьшает RSP на 8 (численно) и сохраняет по полученному адресу src 
  * `pushq $42` сохраняет 8-ми байтовое число 42 на стеке
  * `pushq %RAX`
+ `popq <dst>` - удаляет значение со стека и сохраняет в <dst>
  * `popq %RAX`
+ `movq (%RSP), %RAX` - копируем последнее значение, не удаляя его со стека
