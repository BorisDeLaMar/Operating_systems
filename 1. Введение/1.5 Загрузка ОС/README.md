# Загрузка ОС  
*NB Процесс загрузки ОС зависит от архитектуры и платформы, так что информация будет в обобщенном виде*  
Итак, подаем питание на процессор.  
## Первая инструкция  
Если архитектура x86, то проц обращается по адресу 0xFFFFFFF0 для ее выполнения. Отвечает ему при этом не память, а материнская карта.  
Это связано с тем, что процессор "видит" мир через набор своих контактов, запрос к памяти не более, чем набор сигналов на этих контактах. 
Процессор мы кладем в сокет в материнской карте, поэтому она видит все запросы, посылаемые процессором и может как передать их в память, так и ответить на них 
самостоятельно.  
Отвечает материнская плата кодом, который в ней зашит. Два наиболее частых названия этого кода:
* BIOS (Basic Input/Output System) - наследство IBM PC  
* UEFI (Unified Extensible Firmware Interface) - сложный, про него говорить не будем  
## BIOS  
***С чего начинает свою работу BIOS?***  
С POST (Power-On Self-Test) - проверяет что все необходимые устройства на месте, работают корректно. Кроме этого, на этом этапе может выполняться начальная 
инициализация устройств, а также осуществляется поиск загрузочного устройства (диска с ОС).  
***Как BIOS ищет загрузочный диск?***  
Во-первых, BIOS ищет диск, с которого можно безошибочно прочитать первые 512 байт (первый сектор a.k.a загрузочный). В этом секторе последние 2 байта должны хранить 
числа 0x55 и 0xAA. Если такой сектор найден, он загружается в память по физическому адресу 0x7c00, и BIOS передает ему управление.  
## Окружение  
Теперь мы знаем, куда положить наш код и в каком виде, чтобы он запустился. Но возникает вопрос:  
***В каком окружении он будет работать (в каком состоянии находится процессор ...)?***  
Нам известно, что код начинается по **физическому адресу** 0x7c00 (то есть процессор выставил этот адрес на своих "ногах" (выходах), когда обращается к памяти. Т.е. 
это адрес, указанный в запросе процессора к внешнему устройству (внешней памяти)).  
*NB **Логический адрес** - адрес в том виде, в котором его понимает программа, исполняющаяся на процессоре. Физический адрес не обязательно совпадает с логическим.*  
Также мы знаем, что часть устройств как-то инициализированы, а прерывания отключены.  
Процессор же работает в режиме *Real Mode*. Ранее в блоке про ассемблер для x86 рассматривали только 64-битный режим работы (*Long mode*).  
## Real Mode  
Отличия от Long mode:  
* Логический адрес состоит из 2-х частей: 16-битного сегмента (SEG) и 16-битного смещения (OFF).
  + Эту пару процессор преобразует в физический адрес по формуле (SEG*16 + OFF)mod2^20.
  + Сегмент процессор берет из одного из специальных регистров: CS, DS, SS, ES, FS, GS. Иногда можно указать конкретно, из какого регистра брать сегмент. 
Если процессор обращается к памяти, чтобы достать следующую для исполнения инструкцию, всегда пользуется CS, инструкции для работы со стеком (push, pop...), то
процессор будет использовать SS. Большинство команд копирования из одного места памяти в другое (или регистр) используют по умолчанию DS, реже - ES.
  + Смещение задается по принципу указателей Long Mode (либо явно указываем константой в команде, либо используем метку, либо храним значение в регистре) 
  + В Long Mode просто использовали 64-битное число в качестве адреса (указателя в программе).  
* Размер и количество регистров. В Long Mode - 64-битные, у нас - 16-битные. Также регистров стало меньше и они поменяли свои имена:
  + Вместо RAX - AX. На самом деле в 64-битном режиме AX тоже есть. Как так? Архитектура x86 начиналась именно с 16-битной версии, то есть изначально был AX. 
Потом появилась 32-битная версия как развитие архитектуры и 32-битный EAX. Регистр AX остался, но ссылается теперь на младшие 16 бит EAX.
  + Аналогичная история и с другими регистрами  
## Пример программы для загрузочного сектора диска  
*NB После `;` идет комментарий.*
```Assembler
	.code16 ; Перечисление директив компилятору, которые сообщают что и как надо сгенерировать
	.text
	.global start
start:
	ljmp 0x0, $real_start ; Версия jmp, позволяющая явно указать сегмент. В результате этого кода в CS будет 0, а в IP - $real_start
; Зачем эта инструкция? Мы знаем, что код располагается по физическому адресу 0x7c00, он может быть представлен различными комбинациями сегмента и смещения
; Выполнив start нормализуем представление (занулили сегмент)
real_start:
	movw $0, %ax ; w означает 16-битные операнды
	movw %ax, %ds ; Инициализация других сегментных регистров.
	movw %ax, %ss ; Но почему не movw $0, %ds? Такая инструкция не валидна и процессор не должен ее знать (вот такое странное ограничение архитектуры x86)

	movw $0x7c00, %sp ; инициализация указателя стека
	addw $0x0400, %sp ; нужна просто ссылка на память, куда можно писать. Как-то так вычислили адрес.

	movw $0xB800, %ax ; Чтобы вывести строчку на экран, записать ее нужно именно начиная с этого физического адреса (адрес видеобуфера)
	movw %ax, %es ; Этот адрес надо представить в виде SEG&OFF. Возьмем SEG = 0xB00, OFF = 0
	movw $data, %si ; Копировать строку будем из SEG=ds (дополнительной инициализации этого не нужно), OFF = si (что и делаем этой строкой)
	movw $0, %di ; Пара регистров es&di указывают, куда надо записать строку
	movw size, %cx ; Размер данных, которые будем копировать в видеобуфер
	call memcpy ; Функция копирования
memcpy: ; Копируем в es&di из ds&si размера cx
	cmpw $0, %cx ; Если cx = 0, сразу выходим
	jz out
next: ; Копируем по одному символу в цикле, пока не скопируем cx символов
	movb (%si), %ah ; b - byte, сохраняем в ah (- старшие 8 бит ax) 
	movb %ah, %es:(%di)
	incw %si
	incw %di
	decw %cx
	jnz next
out:
	ret
data: ; Метка, хранящая смещение строчки
	.asiz "H\017e\017l\017l\017o\017!\017" ; \017 - формат вывода на экран (белый текст определенного стиля)
size: ; Метка, указывающая на место в памяти, где лежит информация о размере строчки
	.short . - data
loop: jmp loop ; Пока на процессор подается питание, он не может не исполнять инструкции, поэтому он будет доставать значения из памяти и
; пытаться интерпретировать это как инструкции. Какой мусор он там прочитает - неизвестно, поэтому используем бесконечный цикл
```
*NB Пример рассчитан на то, что его будут собирать с помощью GNU LD*  
## Запуск  
Makefile и другие вспомогательные файлы для запуска: https://github.com/cscenter/OS_online_course/tree/master/week1/load/bios-boot  
1) Пишем в директории со всеми файлами в консоли `make`, появляется файл boot.bin (можно также командой `hexdump -C boot.bin` посмотреть его)
2) `bash start.sh` запуск виртуальной машины с загрузочным диском в виде файла boot.bin  
## Загрузчик реальной ОС  
Обычно код в этих 510 байтах должен прочитать весь непоместившийся код с диска (вся ОС, понятное дело, не поместится в 510 байт). То есть, это будет оставшийся код 
ОС, которому передастся управление, или код вторичного загрузчика (например, GRUB).  
***Зачем вторичный загрузчик?***  
Например, он позволяет выбирать, какую ОС запустить. Также, если его использовать, не нужно думать о том, как загружается ваша платформа (этим займется загрузчик, 
а нам надо лишь знать его минтерфейс).
