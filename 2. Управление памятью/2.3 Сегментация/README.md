# Сегментация  
***Каким образом логическое адресное пространство (далее ЛАП) отображается на физическое (далее, получается, ФАП))?***  
* сегментация (важна для x86)  
* paging (страничная организация памяти)  
## Сегментация в Real Mode  
SEG - идентификатор сегмента физической памяти. Сегмент SEG начинается по физическому адресу SEG*16 и имеет размер 2^16 байт. Это то, что мы знаем из предыдущих 
выкладок. Но что, если разрешить ОС изменять параметры сегмента?  
## Таблица дескрипторов сегментов  
Допустим ОС разбивает физическую память на набор сегментов произвольного размера и про каждый элемент сохраняет информацию (визический адрес начала сегмента 
и его размер) в некоторой таблице. Идентификатором сегмента будет выступать номер записи в таблице.  
После создания такой таблицы ОС сообщит процессору, где она лежит. Таким образом, процессор сможет преобразовывать логические адреса (идентификатор сегмента + 
смещение) в физические адреса.  
## Изоляция и защита с помощью сегментации  
ОС (привелегированный код) выдает каждому процессу свой дескриптор (свою запись в таблице), то есть записывает индекс записи в таблице в сегментные регистры, которые 
будет использовать данный процесс. Каждый дескриптор описывает свой участок физической памяти, и у каждого процесса свой дескриптор. 
Так мы *изолировали* память процессов друг от друга.  
Теперь запретим непривелегированному коду, исполняющемуся в рамках процесса, изменять сегментные регистры для обеспечения *защиты*. Поэтому при использовании 
сегментации логический адрес состоит не из пары SEG+OFF, а только из смещения.  
Ровно так и работает сегментация в т.н. Protected Mode (32-битный режим) архитектуры x86. Называется так, поскольку в отличие от Real Mode, к защищенному добавились 
средства защиты логических адресных пространств (сегментация).  
## Сегментация x86  
В сегментных регистрах хранится **селектор сегмента**, который хранит индекс сегмента из таблицы. Есть еще поля, кроме индекса. Нам интересен только CPL (current 
priviledge layer). В x86 выделяют 4 уровня привилегий:  
* ring0 - ring3
* ring0 - наивысший уровень привилегий (код ядра ОС)
* ring3 - низший (пользовательские приложения)
* CPL хранит уровень привилегий текущего исполняемого кода  
## Примеры  
Пусть у нас есть просто программа с бесконечным циклом. Соберем и запустим ее через дебаггер, который позволит посмотреть на значения регистров во время работы 
приложения:  
```bash  
cc main.c
gdb ./a.out
r
ctrl+C
info registers  
```  
Младшие 2 бита равны 1, то есть CPL=ring3. Теперь запустим модуль ядра Linux, который получает значение регистра CS и выводит его в log:  
```bash
make
sudo insmod getseg.ko   -- загрузка в ядро
dmesg                   -- смотрим log
```
Последние 2 бита нулевые, CPL=ring0. Не забываем `sudo rmmod getseg` для удаления модуля из ядра.  
Код: https://github.com/cscenter/OS_online_course/tree/master/week2/log_mem/kern  
## Global Descriptor Table (GDT)  
Название таблицы дескрипторов для x86. Адрес и размер GDT хранятся в специальном регистре GDTR, который можно читать с помощью инструкций LGDT и SGDT. 
Писать в GDTR может только привелегированный код.
*NB Есть еще и Local, но нам пока достаточно знать про Global*  
*NBB Эффект дежавю может возникать из-за того, что тут все аналогично таблице прерываний IDT*  
## Дескриптор сегмента в Protected Mode  
Является 8-ми байтным значением. Если разбить его на 4 слова, получится:  
![Снимок экрана (355)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/e8b6d491-a9c1-4df2-9f32-e0b4968f5cd4)  
Base - физический адрес начала сегмента (размазано на 3 части, в сумме 32 бита), Limit - размер сегмента (20 бит, но размер задается в виде 4-х килобайтных кусочках, 
поэтому вместе - 32 бита на размер).  
*NB Что значат слова в последних скобках тоже не понял.*  
## Преобразование логического адреса в физический  
На входе есть некий селектор, который хранится в одном из сегментных регистров и смещение (эфективный адрес или logical address). Селектор указывает на какой-то 
дескриптор из GDT, хранящий Base и Limit.  
Первым делом процессор сравнивает смещение с лимитом. Если смещение больше, генерируется исключение, которое обрабатывает ОС (о том, что вышли за границы сегмента). 
Зачастую такая ошибка убивает пользовательское приложение. Если проверка прошла успешно, offset+base = physical address (физический или линейный адрес).  
![Снимок экрана (356)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/314251c3-fc0f-4e14-97eb-ddf9cd768acf)  
## Сегментация в Long Mode  
Практически не используется и обычно ES, DS, FS, GS равны нулю и не ссылаются на валидный дескриптор, а поля Base и Limit дескрипторов игнорируются. 
То есть сегментация не может быть использована для организации ЛАП, но CS и SS все еще хранят CPL в своих 2-х младших битах.  
Вместо этого используется paging, который позволяет даже больше сегментации.
