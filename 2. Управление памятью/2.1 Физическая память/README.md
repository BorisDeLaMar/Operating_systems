# Физическая память  
**Логическая память** - то, как видит память программа. **Логический адрес** - то, что программа использует в качестве указателя на какую-либо ячейку памяти.  
**Физическая память** - то, как процессор воспринимает память, а **физический адрес** - то, что процессор использует, чтобы обратиться к какой-то ячейке памяти.  
Логические адреса отображаются на физические.

Не все, что выглядит как память, является ею на самом деле. С точки зрения процессора, память - все, что соблюдает определенный интерфейс.  
Из этого вытекает то, что не все физические адреса соответствуют памяти. Например, в 1.5 для записи в видеобуфер использовали некоторый "магический" адрес, в 
результате чего на экране появлялись буквы. Это пример побочных эффектов, возникающих когда пишем по каким-то адресам, которые на самом деле соответствуют не памяти, 
а какому-то специальному устройству.  
Бывают также адреса, не соответствующие ни памяти, ни устройству ("дыра").  

То есть, физическое адресное пространство может быть устроено сложно, без *карты памяти* не разобраться.  
## Карта физической памяти  
***Где же взять карту памяти, чтобы использовать ее внутри ОС?***  
* Из документации аппаратной платформы. **Система на кристалле** (SoC) - это когда на одной плате собирается сразу и процессор, и память, и все устройства. В такой 
системе сложно заменить одну память другой или добавить больше памяти, или заменить устройство. Для такого компьютера конфигурация памяти практически не меняется и
можно использовать данный способ.
* Спросить ПО материнской карты (BIOS/UEFI/...), то есть ее прошивку. Это ПО, запускающееся до ОС и обладающее подробными знаниями об оборудовании, установленного в 
нашей системе. Эта прошивка может знать и о конфигурации физической памяти (для BIOS - команда 0xe820, для UEFI - GetMemoryMap)
* Спросить у загрузчика. Загрузчик может взять на себя часть обязанностей ОС, упростив ее разработку. Можем обязать его узнать, как устроена физическая память и 
передать эту информацию ОС (GRUB поддерживает спецификацию multiboot, определяющая интерфейс, согласно которому она может передать ядру ОС эту информацию).
## Пример использования multiboot  
***Что требует эта спецификация от ядра ОС?***  
Файл, в котором содержится ядро, должен быть определенного формата, чтобы загрузчик, поддерживающий спецификацию, мог идентифицировать этот файл как ядро, найти всю 
необходимую для загрузки этого ядра инфомацию в этом файле и загрузить его.  
***Что спецификация требует от загрузчика?***  
Загрузчик должен создать структуру в памяти (multiboot_info structure), и перед тем как передавать управление ядру, сохранил физический адрес этой структуры 
в определенном регистре, чтобы ОС могла обратиться к этой структуре.  
Эта multiboot_info в частности хранит информацию о карте физической памяти.  
Важные поля структуры:  
* flags - содержит информацию о том, какие поля инициализированы в структуре.
* mmap_addr - адрес участка памяти с набором записей фиксированного формата, описывающие регионы физической памяти
* mmap_length - размер этого участка памяти

Код который разбирает карту памяти, дополняет ее памятью занятой ядром ОС и делает из этого простой аллокатор (смотри файлы balloc.h и balloc.c):  
https://github.com/cscenter/OS_online_course/tree/master/week2/log_mem/bootstrap-allocator
