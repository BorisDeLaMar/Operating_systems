# Страничная организация памяти  
Хотим абстрагировать код, исполняющийся на процессоре от физического адресного пространства (далее ФАП), так как устройство физической памяти сложно, а также 
хотим изолировать память одного процесса от другого.  
**Paging** использует словарь, отображающий логические адреса на физические. Ядро ОС создает свой словарь для каждого процесса, и при переключении с одной 
задачи на другую, ядро говорит процессору использовать другой словарь.  

***Что такое страницы словаря?***  
Отображать побайтно будет нееффективно, так как будут слишком большие словари для слишком маленького объема данных. Поэтому отображение происходит блоками 
фиксированного размера (страницами). Размер страницы определяется архитектурой (для x86 типичный размер - 4Kb, а для 64-битного ARM - 65Kb).  
***Как словарь отображает логические страницы на физические?***  
Во-первых, последовательные логические страницы не обязательно отражаются на последовательные физические. То есть каждая отображается *независимо*. Во-вторых, 
для каких-то логических страниц отображения может вовсе не быть, или 2 логические страницы (в том числе и разных процессов) могут быть отражены на одну и ту же 
физическую.  
***Что будет, если код обратиться к несуществующей логичесукой страницы?**  
Процессор попробует ее отобразить, не найдет соответствующего отображения и выдаст Page Fault. Эта ошибка также генерируется и в следующих случаях:  
+ Попытки записи в какой-то участок логической памяти, для которой установлен специальный флаг запрета записи.
+ Попытки исполнения кода из участка с запретом этого (полезно для борьбы с уязвимостями переполнения буфера)
+ Попытки непривелегированного кода обратиться к участку с запретом этого. Таким образом можем отобразить код ядра ОС в ЛАП процесса и запретить ему обращаться по 
данным адресам
***Как должен выглядеть словарь?***  
Не каждый процесс использует все логическое адресное пространство (далее ЛАП), поэтому структура словаря должна позволять не тратить память на те страницы, которые 
мы не используем. Также мы хотим, чтобы эта структура была достаточно простой, так как несмотря на то, что структуру создает ОС, использует ее процессор (т.к. он 
преобразует ЛАП в ФАП). Ожидать, что процессор знает, что такое дерево поиска, и умеет найти значение по ключу или что-то в этом духе, будет оптимистично.  
То есть, классические структуры данных не подойдут. На практике использует структура, похожая на **цифровое дерево**.  
## Таблица страниц  
**Таблица страниц** - структура, использующаяся для отображения ЛАП в ФАП. На самом деле, это группа страниц, объединенных в дерево. Высота дерева определяется 
архитектурой и, зачастую, фиксируется.  
Процессор в каком-то виде хранит физический адрес *корневой таблицы* этого дерева.  
***Как процессор по логической страницы ищет физическую?***  
Логический адрес - 32 или 64-х битное число (в зависимости от архитектуры). Разобъем его на 2 части:  
+ страшние биты - номер логической страницы
+ младшие - смещение внутри этой страницы  
Процессор разбивает номер страницы на несколько частей. Далее он берет физический адрес корневой страницы и использует старшую из частей разбитого номера в качестве
индекса в этой странице-таблице. Полученная запись хранит физический адрес таблицы следующего уровня. На последнем из уровней в таблице будет физический адрес
целевой физической страницы для данного номера логической страницы. Далее процессор просто обращается по заданному смещению на этой странице.
## Translation Lookaside Buffer (TLB) 
В результате такого хранения, вместо 1 обращения в память, мы сначала смотрим в n-ое количество таблиц и только потом читаем нужный байт, что в n раз замедляет 
весь процесс. Поэтому, в современных процессорах есть специальный кэш, сохраняющий результаты трансляции логических страниц на физические.  
Это кэш и называется TLB. Важно заметить, что если код каждым своим новым запросом обращается к новой странице, то кэш не будет ускорять процесс.  
С использованием этого буфера есть одна проблема: процессор хранит только адрес корневой таблицы. Если ОС изменитт адрес в одной из таблиц, процессор об этом не 
узнает и закэшированный ранее адрес может стать невалидным. Задача ядра ОС - удалять такие записи из TLB.  
## Paging в x86 Long Mode  
В 64-битном режиме используется 4-х уровневая таблица старниц. Адрес корневой таблицы хранится в регистре CR3, каждая таблица занимает 4Kb и должна быть 
**выровнена** на границу 4-х Kb. То есть, физический адрес начала таблицы должен быть кратен 4Kb. В каждой таблице 512 записей, каждая по 8 байт.  
Также важно заметить, что старшие 16 бит логического адреса не учавствуют в отображении, и требуется, чтобы все они были того же значения, что и 47-ой бит 
(начало старших байт адреса). В противном случае будет сгенерировано исключение.  

В x86 размер страницы не фиксируется жестко и может быть 4Kb, 2Mb или 1Gb. Это возможно благодаря тому, что в записях таблиц 2 и 3-его уровня есть специальный 
бит - **PS бит** (Page Size). Если он установлен, запись в таблице ссылается на финальную страницу (не на таблицу следующего уровня). В таком случае, оставшаяся 
часть логического адреса содержит смещение внутри этой большой страницы, а не адрес следующих + смещение.  
## Структура записи в таблице страниц  
Кое-какие поля пропущены, остановимся на самых важных.  
Если P (бит присутствия) = 0, то процессор при попытке трансляции генерирует page fault (запись не описывает никакой маппинг, она не валидна)
![Снимок экрана (358)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/f0de186d-ca80-466d-bcf7-b808a5559601)
