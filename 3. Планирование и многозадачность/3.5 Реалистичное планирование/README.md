# Реалистичное планирование  
Рассмотрим алгоритм **Round Robin**, который выдает потокам квант времени CPU по очереди:
* Если поток отработал свой квант времени и не отдал добровольно управление, ОС снимает его с процессора и ставит в конец очереди
* Каждый новый поток встает в конец очереди
* Потоки, вызвавшие IO операцию, отдают управление добровольно, ждут завершения этой операции и после этого встают в конец очереди
* CPU отдается потоку, находящемуся в начале очереди  
Такой алгоритм достаточно прост, что хорошо, так как планировщик работает в ядре ОС, а оно работает в привелегированном режиме. То есть, если в реализации планировщика
допустить ошибку, будет плохо.

Недостаток Round Robin заключается в том, что IO bounded задачи при таком алгоритме отрабатывают с задержкой: когда мы нажимаем на клавишу, происходит прерывание, 
которое будит поток текстового редактора и ставит его в конец очереди на CPU. Ожидание этого потока в очереди для пользователя будет выглядеть как задержка при вводе 
(отрисовка буквы случится только когда поток дождется своей очереди).  

***Из каких соображений стоит выбирать квант времени?***  
Чем больше квант, тем меньше доля времени на переключение (так как переключение - тоже код), но больше время отклика каждого процесса в отдельности.  
## Планировщик Windows  
* Потокам на винде назначен приоритет, состоящий из класса и приоритета внутри класса (всего 32 различных приоритета)
* На исполнение выбирается поток с наивысшим приоритетом
* Несколько потоков могут иметь одинаковый приоритет. Для них используется алгоритм Round Robin
* Чтобы избежать неограниченного голодания потоков, винда иногда повышает им приоритет:
  + если поток отвечает за видимую часть UI
  + при получении ввода или завершении операции IO
  + для случайно выбранных потоков, чтобы избежать некоторых классов проблем  
## Один из планировщиков Linux  
**Completely Fair Scheduler (CFS)**:
* Для каждого потока поддерживается виртуальное время, увеличивающееся когда поток работает
* CPU отдаем потоку с наименьшим виртуальным временем
* В ядре Линукса все потоки поддерживаются в виде красно-черного дерева, упорядоченного по виртуальному времени. То есть выбирается самый левый узел дерева
* Реальная реализация сложнее, так как в таком виде, если поток долго ждал IO, планировщик выдаст ему слишком много времени, чтобы он догнал других по виртуальному 
времени
