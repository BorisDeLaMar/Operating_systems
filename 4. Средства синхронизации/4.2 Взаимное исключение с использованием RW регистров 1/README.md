# Взаимное исключение с использованием RW регистров часть 1  
Процессор предоставляет различные средства для реализации блокировки.  
**Атомарный RW регистр** - одно из таких средств, ячейка памяти (не обязательно регистр) и пара операций:  
* write - атомарно записывает значение в регистр
* read - атомарно читает последнее записанное значение
* Все операции read/write упорядочены, не происходят одновременно. Именно это свойство понимается здесь под атомарностью.  
*NB Мы можем использовать более чем один атомарный регистр. В этом случае мы преполагаем, что так же, как и с одним атомарным регистром,
операции над всеми регистрами упорядочены и этот порядок согласуется с порядком инструкций в программе*
## Пример реализации на псевдокоде  
Представим, что есть только 2 потока с идентификаторами 0 и 1 соответственно. Тогда реализация может быть следующей:  
![Снимок экрана (365)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/1c4b1d74-7904-42a4-94b5-3e91fbd09b45)  
В данном примере `atomic_store` - установка значения. В `lock_init` зануляем RW регистр, который здесь обозначен как `last`.  

Для данного случая реализацией гарантируется взаимное исключение:
* в `lock` зависает только один из потоков (у которого threadID = lock->last)
* Значение `last` меняется только в функции `unlock`

А вот свойство живости не выполняется, так как изначально поток с threadID = 0 зависает в цикле, и если поток 1 не сделает unlock, нулевой зависнет навсегда при 
попытке залочить критическую секцию. То есть потоки могут блокировать секцию только попорядку. Сначала 1, потом 0 и дальше по кругу.  
## Другая реализация  
![Снимок экрана (367)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/56854793-cd88-4262-962b-938941ee8d9d)  
В этой реализации каждому потоку сопоставили флаг намерений (всего по-прежнему 2 потока): 0 - потоку не нужна блокировка, не пытается войти в критическую секцию, 1 - 
соответственно наоборот. `me` и `other` - идентификаторы этих 2-х потоков (0 и 1).  
Такая реализация все равно не поддреживает свойство живости, так как если у обоих потоков будет флаг = 1, они будут вечно крутиться в цикле и ни один не сможет этот 
флаг поменять (вызвать `unlock`).  
## Алгоритм Петерснона для 2-х потоков  
![Снимок экрана (368)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/41a5c2ab-b5eb-4bfb-b39c-3743cda32fe0)  
Как видим, это дифиле из 2-х вышеописанных алгоритмов. Внутри `lock` теперь имеем 3 атомарных регистра.  

***Соблюдается ли взаимное исключение?***  
Докажем это свойство от противного: пусть оба потока находятся одновременно в критической секции. Тогда они оба записали значение в атомарный регистр `last`. 
Регистр атомарен, поэтому какая-то из записей была там первой, а другая - последней. Пусть последним был поток 1. Тогда last = flag1 = flag0 = 1. Но тогда 
выполняется условие цикла в `lock` и поток 1 не мог из него выйти. Получили противоречие.  

***Соблюдается ли живость?***  
Пусть для определенности поток 0 пытается войти в критическую секцию. Тогда возможны 2 ситуации:
* lock->flag[1] == 0, то есть поток 1 не пытался захватить блокировку, условие цикла не выполняется, нулевой входит в критическую секцию
* lock->flag[1] == 1, тогда тот, кто записал в `last` последним, останется висеть в цикле, а первый войдет в критическую секцию
