# Состояние гонки по данным и взаимное исключение  
**Состояние гонки** - результат зависит от порядка выполнения инстуркций. Проблем несколько:  
* Порядок зависит от слишком многих факторов
* На решения планировщика влияют другие потоки, а также прерывания, которые могут происхожить асинхронно исполняющемуся коду
* Это состояние трудно протестировать  
**Критическая секция** - участок кода, обращающийся к разделяемым несколькими потоками данным. Если не более, чем один поток может одновременно находиться в критической
секции, то состояния гонки не будет.

**Блокировка** - некоторый объект (структура) и пара методов для работы с ним:
* lock - метод захвата блокировки. Поток должен вызвать этот метод для соотвествующей блокировки перед тем, как войти в критическую секцию
* unlock - метод освобождения блокировки, вызывабщийся потоком по выходу из критической секции  
Блокировка должна предоставлять гарантию **взаимного исключения** (mutual exclusion):
* Потоки вызывают lock и unlock парами
* Не более 1 потока может одновременно находиться между lock и unlock. Если 2 потока одновременно вызовут lock, один из них должен пройти дальше (lock вернет ему 
управление), а второй должен ждать внутри функции lock, пока первый не вызовет unlock.
*NB Для разных критических секций, надо использовать разные блокировки, так как в общем случае одна критическая секция не зависит от другой. В этом контексте удобно
рассматривать блокировку как способ защитить данные. Каждая блокировка защищает какие-то связанные с ней данные.*

**Свойство живости (deadlock freedom)** - если один из потоков вызвал lock, какой-то из потоков, вызвавших lock, захватил блокировку (кому-то отдадут блокировку). 
То есть, если поток единственный пытается захватить блокировку, то он не ждет в lock. В противном случае ждем, если другому потоку повезло захватить блокировку.
## Пример  
Пусть есть функция инкрементирования, которую вызывают 2 потока:  
```Assembler
movq counter, %rax
inc %rax
movq rax, counter
```
Если сначала выполнится первый, а потом второй, итоговое значение counter = 2, но если сначала выполнилась первая строчка первого потока, затем произошло переключение 
на второй, в котором тоже выполнилась только инициализация rax, то в обоих потоках в rax изначально 0 лежит и по завершении отработки двух инкрементирований 
counter = 1.  
counter в данном примере - разделяемые между потоками данные (к ней обращаются несколько потоков).
