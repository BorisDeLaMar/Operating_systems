# Взаимное исключение с использованием RW регистров часть 2  
## Обобщение алгоритма Петерсона на N потоков  
![Снимок экрана (368)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/339e2664-f798-4d1e-890e-ea675e6e9ee1)    
Теперь у нас будет N флагов в структуре блокировки, а в цикле проверяем флаги всех потоков, кроме исполняющегося. `flags_clear` помогает в этом: если хотя бы один из 
флагов других потоков не нулевой, она возвращает 0. Остальное без изменений.  
Такая реализация не гарантирует взаимное исключение N потоков, но обеспечивает вот что: если только один поток пытался вызвать `lock_one`, то он не будет там ждать. 
Если вызвавших было несколько, на `lock_one` задержится только один, остальные пройдут вперед.  
У нас есть алгоритм, выбирающий одного проигравшего, сделаем теперь N-1 проигравший поток, определим победителя:  
![Снимок экрана (370)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/12696eaa-5b2d-47f1-9cfb-d6fc848aaf4a)  
Проблема в квадратичном росте памяти: у нас N флагов (по одному на поток) для N-1 блокировки. Заметим, что для каждого потока набор из N-1 флага таков, что сначала 
идет какое-то количесвто 1, а потом все нули (проиграл раз и навсегда). Тогда есть смысл хранить только длину префикса из единиц:  
![Снимок экрана (371)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/d83fc893-2fbd-4f7b-bf9b-a710c73513e7)  
Будем хранить длину префикса в поле `level`, а дальше проведем N-1 соревнование как до этого. Только теперь вместо флага записываем уровень. `flags_clear` теперь будет 
сверять `level` с переданным параметром, не приводится для краткости.  
## Честность  
Если поток захотел захватить блокировку, мы хотим, чтобы когда-нибудь ему это удалось. Это не обеспечивается условием живости, так как оно говорит лишь о тои, что 
среди всех потоков, пытающихся захватить блокировку, найдется один, которому это удастся.  
*k-ограниченное ожидание* - после того, как поток изъявил желание захватить блокировку (встал в очередь), не более k потоков могут пролезть вперед него без очереди. 
В таком подходе есть одна неприятность: даже если потоку выдано процессорное время и блокировка никем не захвачена, он выполнится позже других потоков в очереди 
(ОС должна будет дать этим потокам время на CPU, они должны выполниться, и только потом очередь нашего процесса). 
