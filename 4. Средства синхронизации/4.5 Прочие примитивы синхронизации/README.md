# Прочие примитивы синхронизации  
## Разделение на читателей и писателей  
Если есть несколько потоков, которые читают и записывают данные в одну и ту же структуру, то чтение (например, для поиска данных) сразу нескольких потоков можно было бы 
сделать одновременным.  
То есть хотим реализовать примитив синхронизации, позволяющий нескольким читателям одновременно обращаться к структуре данных, а писателю производить изменения в 
структуре данных монопольно.  

Возможная реализация разделения на читателей и писателей в псевдокоде:  
![Снимок экрана (375)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/1ab64d83-ad58-4a9d-9b5d-138f841af27d)  
![Снимок экрана (376)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/cd15c54f-699d-46bd-ba7e-bf38b21733f1)  
Каждый поток все еще обладает талончиком (`ticket`) в очереди, но теперь их две: `write` и `read`. Читатель захватывает блокировку в `read_lock`, получая `ticket`, 
далее ждет своей очереди в цикле. Перед входом в критическую секцию смотрит, являестся ли следующий за ним читателем. Если это подтверждается, то продвигаем очередь 
вперед. Таким образом, второй читатель также сможет войти в критическую секцию. Очередь писателей продвигаем только после окончания блокировки.  
Писатель также получает талон, ждет своей очереди. По завершении продвигает обе очереди вперед.  
## Стратегии ожидания  
До сих пор потоки ждали своей очереди в цикле. Такое ожидание называется **активным**, а соответствующие им блокировки - **spinlock-ами**, потому что потоки "крутятся" в 
цикле. Такое ожидание хорошо отрабатывает, если:  
* Потоки не держат блокировку долго
* Блокировка не находится под сильной нагрузкой

***Как ожидать неактивно?***  
* Добровольно отдать CPU другому потоку. Проверять в цикле свободна ли блокировка и, если нет, вызывать планировщик
* Можно пометить поток как неактивный, чтобы планировщик не давал ему время CPU, пока блокировка не будет отпущена. Ожидание на IO операции зачастую реализуется с 
использованием примитива синхронизации

Блокировки такого подхода называются **mutex** (Mutual Exclusion).
## Задача Producer-a и Consumer-a  
Есть потоки, генерирующие данные, - Producer. Consumer - потребляющие потоки, соответственно.  

***Как синхронизировать Producer-ов и Consumer-ов, если они работают с разной скоростью?***  
Такую задачу позволяет решить примитив, называющийся **переменная состояния (condition variable)**. Это объект и несколько методов для работы с ним:
* `wait` - ожидает, пока кто-нибудь просигналит (сработает один из 2-х методов ниже)
* `notify_one` - просигналить одному из ожидающих
* `notify_all` - просигналить всем ожидающим  
## Реализация в псевдокоде  
Верхние 3 строчки - реализация блокировки, которая всегда идет парой с condition variable. Структуру последней в деталях рассматривать не будем.  
*NB Блокировка, передающаяся в метод `wait`, должна быть уже захвачена. Внутри в какой-то момент метода `wait` отпустит блокировку. А когда его нотифицируют, 
он попробует снова захватить ее и вернуть управление. Соответственно, при вызове нотификатора должна быть захвачена та же блокировка, что используется в `wait`, 
хоть в них в качестве параметров она и не передается.*  
![Снимок экрана (377)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/cd342f32-a464-40b1-9473-90ce767e3a4a)  
Значения, сгенерированные producer, будем хранить в переменной `value`. Флаг `valid_value` хранит 1, если в `value`  хранится реальное значение, которое еще никто не 
обработал. 0 соответствует какому-то неосмысленному значению в `value` (значение забрали, либо не успели положить). Флаг `done` устанавливается продюссерами в случае 
завершения подачи данных.  
Кроме того имеем `lock`  
![Снимок экрана (378)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/da7bff99-e109-4a10-adc9-497e34d583c7)  



