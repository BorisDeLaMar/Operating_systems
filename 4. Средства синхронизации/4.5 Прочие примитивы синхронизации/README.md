# Прочие примитивы синхронизации  
## Разделение на читателей и писателей  
Если есть несколько потоков, которые читают и записывают данные в одну и ту же структуру, то чтение (например, для поиска данных) сразу нескольких потоков можно было бы 
сделать одновременным.  
То есть хотим реализовать примитив синхронизации, позволяющий нескольким читателям одновременно обращаться к структуре данных, а писателю производить изменения в 
структуре данных монопольно.  

Возможная реализация разделения на читателей и писателей в псевдокоде:  
![Снимок экрана (375)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/1ab64d83-ad58-4a9d-9b5d-138f841af27d)  
![Снимок экрана (376)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/cd15c54f-699d-46bd-ba7e-bf38b21733f1)  
Каждый поток все еще обладает талончиком (`ticket`) в очереди, но теперь их две: `write` и `read`. Читатель захватывает блокировку в `read_lock`, получая `ticket`, 
далее ждет своей очереди в цикле. Перед входом в критическую секцию смотрит, являестся ли следующий за ним читателем. Если это подтверждается, то продвигаем очередь 
вперед. Таким образом, второй читатель также сможет войти в критическую секцию. Очередь писателей продвигаем только после окончания блокировки.  
Писатель также получает талон, ждет своей очереди. По завершении продвигает обе очереди вперед.  
## Стратегии ожидания  
До сих пор потоки ждали своей очереди в цикле. Такое ожидание называется **активным**, а соответствующие им блокировки - **spinlock-ами**, потому что потоки "крутятся" в 
цикле. Такое ожидание хорошо отрабатывает, если:  
* Потоки не держат блокировку долго
* Блокировка не находится под сильной нагрузкой

***Как ожидать неактивно?***  
* Добровольно отдать CPU другому потоку. Проверять в цикле свободна ли блокировка и, если нет, вызывать планировщик
* Можно пометить поток как неактивный, чтобы планировщик не давал ему время CPU, пока блокировка не будет отпущена. Ожидание на IO операции зачастую реализуется с 
использованием примитива синхронизации

Блокировки такого подхода называются **mutex** (Mutual Exclusion).
## Задача Producer-a и Consumer-a  
Есть потоки, генерирующие данные, - Producer. Consumer - потребляющие потоки, соответственно.  

***Как синхронизировать Producer-ов и Consumer-ов, если они работают с разной скоростью?***  
Такую задачу позволяет решить примитив, называющийся **переменная состояния (condition variable)**. Это объект и несколько методов для работы с ним:
* `wait` - ожидает, пока кто-нибудь просигналит (сработает один из 2-х методов ниже)
* `notify_one` - просигналить одному из ожидающих
* `notify_all` - просигналить всем ожидающим  
## Реализация в псевдокоде  
Верхние 3 строчки - реализация блокировки, которая всегда идет парой с condition variable. Структуру последней в деталях рассматривать не будем.  
*NB Блокировка, передающаяся в метод `wait`, должна быть уже захвачена. Внутри в какой-то момент метода `wait` отпустит блокировку. А когда его нотифицируют, 
он попробует снова захватить ее и вернуть управление. Соответственно, при вызове нотификатора должна быть захвачена та же блокировка, что используется в `wait`, 
хоть в них в качестве параметров она и не передается.*  
![Снимок экрана (377)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/cd342f32-a464-40b1-9473-90ce767e3a4a)  
### Producer  
Значения, сгенерированные producer, будем хранить в переменной `value`. Флаг `valid_value` хранит 1, если в `value`  хранится реальное значение, которое еще никто не 
обработал. 0 соответствует какому-то неосмысленному значению в `value` (значение забрали, либо не успели положить). Флаг `done` устанавливается продюссерами в случае 
завершения подачи данных.  
Кроме того имеем `lock` и 2 condition variable, связанных с ним. `full` нужен, чтобы сообщить, что какое-то новое значение положили в `value`, а на `empty` будем сигналить, когда значение из буфера забрали из `value`.  
Функции `produce` передается сгенерированное значение в качестве параметра. Эта функция должна положить значение в `value` и сообщить, что буфер заполнен (выставить флаг). Все это она делает только в случае, если в `value` еще не лежит значения. Если переменная занята, функция ждет ее освобождения.  
`lock(mtx)` - захват блокировки, связанной с нашими condition variabl-ами. В цикле ждем на переменной состояния `empty`, из которой просигналят в случае освобождения переменной `value`.  
*NB На строке `value = x` блокировка все еще захвачена, так как `wait` сначала отпускает блокировку, а затем снова ее забирает.*    
После присвоения сигналим consumer-ам о новом значении.  
Когда producer-ы закончат отправку данных, вызываем `finish`, блокируем по переменным состояниям и будим всех consumer-ов, ожидающих на переменной `full`.  
![Снимок экрана (378)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/da7bff99-e109-4a10-adc9-497e34d583c7)  
### Consumer  
Аргумент `consume` указывает на место, куда нужно сохранить сгенерированное produce-ром значение, возвращает 1, если записали какое-то реальное значение, и ноль, если значений на produce-ре больше не будет.  
В цикле ждем на переменной `full` (на которой будут сигналить `produce` и `finish`) либо генерации какого-то значения, либо пока не скажут, что данные закончились (`!done`).  
Если дождались валидного значения, возвращаем его и нотифицируем produce-ра, чтобы он мог сгенерировать новое значение.  
Если consumer потребляет данные быстрее, чем producer-ы успевают их генерировать, consumer зависнет в цикле `while`.  
При обратной ситуации produce-р зависнет в цикле в функции `produce`.  
![Снимок экрана (393)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/4221295b-e7ce-4210-875b-25b0fc3169f3)  
### Вопросы  
***Зачем lock?***  
Пусть блокировки не будет, и один поток вызывает `consume`, а другой - `finish`. Пусть CPU получает первый, тогда он проверяет условие цикла. Пусть его снимают с процессора сразу после проверки условия `!done`, и ставят на процессор второй поток. Тогда `finish` выставит флаг `done` и нотифицирует тех, кто ждет в `wait` (первый поток еще не ждет, не успел `wait` вызвать). При возвращении управления первому потоку, он будет вечно ждать, так как пропустил нотификацию.  
***Зачем ждать в цикле (почему не if)?***  
Пусть есть 2 consumer-а и 1 producer. Первыс получаем CPU C0. Он захватывает блокировку, проверяет условия и ждет. Далее включается P0. Он захватывает блокировку, после чего процессор отдали C1 и он тоже захватил блокировку (захват будет не успешен, так как ее уже захватил C0). C1 зависает в `lock`. Продюссер тем временем генерирует значение, и нотифицирует кого-то из consumer-ов. Так как единственный ждущий - C0, то его и будим. Далее producer отпускает блокировку, чтобы C0 смог продолжить работу (`wait` сначала отпускает блокировку, а потом снова захватывает в C0).  
Имеем 2 потока, борящихся за блокировку: C1, повисший в `lock` и C0, пытающийся захватить блокировку внутри `wait`.  
Выиграть может любой, так что пусть победу одержал C1. Он захватывает блокировку, проверяет условие, видит сгенерированное значение и съедает его, отпускает блокировку.  
После этого C0 захватывает блокировку и видит, что значения нет (только что C1 съел), но вместе с тем его разбудили, сказав, что значение есть.  
Чтобы избежать таких спонтанных пробуждений (**spurious wakeups**), делаем в цикле.  
Схема вышеописанного:  
![Снимок экрана (394)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/50c2c7f1-0a29-42b6-bee7-11afdac8d3cc)



