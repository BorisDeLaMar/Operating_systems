# Взаимное исключение с использованием RWM регистров  
**Атомарный RWM (Read/Modify/Write) регистр** позволяет за одну операцию:
* Прочитать значение в регистре
* Преобразовать некоторым образом прочитанное значение
* Записать преобразованное значение назад

Реализация может выглядеть так:  
![Снимок экрана (372)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/f294eb36-ebae-4c9f-b680-26ccbdfa3d5c)  
Все, что написано внутри блока - одна большая и сложная атомарная операция. Варианты функции f:
* atomic_exchange - возвращает старое значение, записывает новое. Эта функция может показаться эквивалентной паре atomic_load и atomic_store, но это не так. Между 
двумя разными операциями может вклиниться что угодно. В случае atomic_echange такого не происходит (атомарная как и две функции ниже)
* atomic_fetch_{add|sub|or|and|xor} - выполняет арифметическое действие над атомарным регистром
* atomic_compare_exchange - записывает новое значение, если старое равно заданному  
## Реализации RWM регистра  
x86 поддерживает RWM операции, а синтаксис следующий:
* `xchg`
* `lock add`, `lock sub`, `lock or`, ...
* `lock cmpxchg`

ARM, например, поддерживает LL/SC:
* LL (load-link) - загружает значение из памяти
* SC (store-conditional) - записывает новое значение в ячейку, но только если после LL эту ячейку никто не трогал (предполагается та же ячейка памяти, из которой LL 
прочитал значение
Таким образом, LL/SC идут парами и работают вместе как одна RMW операция.
## Реализация взаимного исключения с использованием RWM  
![Снимок экрана (373)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/dde3bbbd-d1bb-40ec-aa7b-110a1e605a0a)  
Внутри функции `lock` пробуем в поле `lock` записать LOCKED и смотрим, какое там было значение до этого: если было UNLOCKED, значит изменили поле `lock`, захватили 
блокировку. Если было записано LOCKED, ждем пока не удастся изменить значение с UNLOCKED на LOCKED.  
Такой код гарантирует взаимное исключение и живость. 

***А что с честностью?***  
Если блокировка под большой нагрузкой (high contention), то есть когда много потоков пытаются ее захватить, блокировка будет постоянна занята. Получается, что 
потоки получают время CPU и просто ждут, так как ее использует другой поток. То есть легко может быть поток, который никогда так ее и не получит, что нечестно.  
## Реализация с k-честностью  
![Снимок экрана (374)](https://github.com/BorisDeLaMar/Operating_systems/assets/91004615/d47150d1-1b5f-4e4e-83bd-9f09a8601295)  
`lock` содержит 2 атомарных регистра, `ticket` - номер потока в очереди, `next` - какой `ticket` захватывает блокировку следующим. 
